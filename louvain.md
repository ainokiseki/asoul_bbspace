# 带权有向图的Louvain算法

## 基本原理

1. 将所有节点视作大小为1的簇

2. 随机遍历每个节点，查找与节点相邻的所有簇，检查将节点放入其中后增加的modularity，选择能使modularity增长幅度最大的簇，将节点移入其中

3. 重复第2步，直到没有任何移动操作可以增大图的总modularity

4. 将每个簇视作新的节点，簇a到簇b的边权即为所有a中节点到b中节点的边的权值之和，构成新图

5. 对新图执行以上操作，直到图的总modularity不再增加

## 实现细节

1. modularity的定义，论文中为![image](https://user-images.githubusercontent.com/43086824/158058617-14a07b9f-7473-4cba-b16c-54a0596ac9f3.png),但实际计算时，使用![image](https://user-images.githubusercontent.com/43086824/158058630-298847a8-43ed-48df-9a60-907e718992ae.png)
,后者为所有簇的内部边权和-（总入边权和×总出边权和）/图总边权和，其中内部边权和为簇中所有点两两之间的边的边权和，总入边权和为簇中所有点的带权总入度之和，既包括内部边也包括外部边

2. 实际计算将点i并入簇C的modularity的改变时，公式为：点i与簇C间的总边权和-（i的带权入度×C的带权出度+i的带权出度×C的带权入度）/图总边权和

3. 对点i计算时，亦需要考虑将点i留在现有簇中的收益。即：每次计算时先将i从原有簇中取出，再考虑将其加入哪个相邻的簇中

4. 对于有向图，i与C“相邻”有两种解释方式：存在从i到C的有向边，或存在从C到i的有向边。本算法采用第一种解释。
